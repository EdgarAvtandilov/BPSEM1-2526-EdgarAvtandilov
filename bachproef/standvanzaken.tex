\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

\section{De nood aan netwerkautomatisatie}
\label{sec:automatisatie}

Constante beschikbaarheid is de dag van vandaag zeer belangrijk in een bedrijfscontext.
Niet beschikbaar zijn, is voor bedrijven meer dan een kwestie van hun website die niet beschikbaar is. 
Downtime brengt ook grote kosten met zich mee. Zo toont een onderzoek van het Uptime Institute aan dat downtime voor 54\% van respondenten van hun enquête kosten van meer dan \$100.000 met zich mee brengt, en voor 1 in 5 respondenten liep dit op naar meer dan \$1.000.000 \autocite{UptimeInstitute2025}. 
Dit onderzoek toont ook dat netwerk- en/of connectiviteitproblemen de oorzaak zijn van 34\% van IT-gerelateerde downtime. 
Een netwerk met 20 netwerktoestellen configureren vraagt om honderden configuratieregels, wat op zijn beurt honderden kansen voor een menselijke fout biedt.
Netwerken worden traditioneel via de command line interface (CLI) geconfigureerd. 
Hoewel dit volledige controle geeft, toont het onderzoek van Uptime Institute aan dat menselijke fouten bijdragen tot 40\% van fouten die downtime veroorzaken \autocite{UptimeInstitute2025}. 
Menselijke interactie minimaliseren bij netwerkconfiguratie zou dus een perfecte oplossing kunnen bieden. Volgens \textcite{Gartner2023} gebeurd meer dan 65\% van alle netwerktaken manueel, hoewel er wel een stijgende trend is in het aantal bedrijven die meer dan de helft van hun netwerktaken automatiseren. 
Deze inefficiëntie heeft niet alleen impact op de operationele kosten, maar ook op de innovatiecapaciteit van IT-afdelingen. 
De complexiteit van moderne netwerken neemt ook toe. 
Uit cijfers van \textcite{shi2021devicegrowth} blijkt dat het totaal aantal netwerk- en verbonden apparaten wereldwijd tussen 2016 en 2021 is gestegen van 17,1 miljard naar 27,1 miljard, een toename van ongeveer 58\%. 
Hoewel er geen specifieke wereldwijde cijfers beschikbaar zijn voor de groei in afzonderlijke netwerkcomponenten zoals switches, routers en access points, kan logischerwijs worden aangenomen dat deze categorieën meegroeien met het totale aantal verbonden apparaten. 
Deze apparaten vormen immers de infrastructuur die nodig is om de groeiende hoeveelheid verbonden eindpunten te ondersteunen. 
Deze grotere, complexere netwerken zorgen ervoor dat automatisatie geen luxe meer is, maar een noodzaak. 
Automatisatie biedt een antwoord op deze problemen door configuraties te centraliseren, sneller, reproduceerbaar en consistent, schaalbaar en foutloos te maken \autocite{Wagbrant2022}. 
Volgens \textcite{Mahant2024networkautomation} kunnen organisaties die netwerkautomatisering implementeren hun configuratietijd met ~85\% reduceren en het aantal configuratiefouten verminderen met 78\%.

\section{Vergelijking van automatiseringstools}
\label{sec:tools}

Binnen netwerk- en infrastructuurautomatisatie bestaan meerdere tools die configuratiebeheer ondersteunen. 
Hoewel ze vergelijkbare doelen nastreven, verschillen ze sterk in architectuur, werkwijze en geschiktheid voor traditionele netwerkapparatuur zoals routers en switches. 
Hieronder volgt een gestructureerde vergelijking van de meest relevante oplossingen.

\subsection{Agent-based versus agentless architectuur}
\label{subsec:agent-vs-agentless} 

Een fundamenteel onderscheid tussen automatiseringstools is of ze een agent vereisen op de managed nodes. 

\textbf{Agent-based tools} zoals Puppet en Chef installeren software op elk te beheren systeem. 
Deze agent communiceert met een centrale server en voert configuratiewijzigingen uit. 
Het voordeel is dat agents proactief de gewenste state kunnen handhaven door regelmatig te controleren en corrigeren. 
Het nadeel is dat agents resources consumeren, zelf moeten worden beheerd en niet op alle netwerktoestellen beschikbaar zijn. 

\textbf{Agentless tools} zoals Ansible werken via standaardprotocollen zoals SSH of API's zonder dat er software hoeft te worden geïnstalleerd op de te configureren toestellen. 
Dit maakt ze bijzonder geschikt voor netwerktoestellen die geen mogelijkheid bieden om third-party software te installeren. 
Het nadeel is dat configuratiewijzigingen moet worden gepushed vanuit een centrale control node in plaats van dat nodes proactief hun staat handhaven.

\begin{itemize}

  \item \textbf{Puppet}  \autocite{PuppetLabsDocs}
        \begin{itemize}
          \item Agent-based architectuur: elk toestel vereist een Puppet-agent.
          \item Declaratieve configuratietaal.
          \item Minder bruikbaar op klassieke netwerktoestellen waar geen agent kan draaien.
        \end{itemize}

  \item \textbf{Chef}  \autocite{ChefSoftwareDocs}
        \begin{itemize}
          \item Agent-based, gebruikt een centrale Chef-server.
          \item Configuraties worden geschreven in Ruby.
          \item Hoge uitbreidbaarheid maar steile leercurve door de nood aan programmeerkennis in Ruby.
          \item Beperkt inzetbaar voor netwerktoestellen waar geen agent kan worden geïnstalleerd.
        \end{itemize}

  \item \textbf{Ansible}  \autocite{AnsibleDocs}
        \begin{itemize}
          \item Volledig agentless: werkt via SSH of API's, ideaal voor netwerktoestellen.
          \item Configuraties worden beschreven in YAML, zeer leesbaar en toegankelijk.
          \item Grote collectie netwerkmodules (\emph{Cisco IOS}, \emph{IOS-XE}, \emph{NX-OS}, \emph{Arista EOS}, \emph{JunOS}, ...). \autocite{AnsibleCommunityNetworkModules}
        \end{itemize}

  \item \textbf{Python (met Netmiko, NAPALM, Paramiko)}  
        \begin{itemize}
          \item Python zelf is geen configuratietool, maar vormt de basis van veel netwerkautomatisatie.
          \item Libraries zoals Netmiko, NAPALM en Paramiko kunnen:
                \begin{itemize}
                  \item CLI-commando's automatisch uitvoeren op routers en switches,
                  \item configuraties opvragen, verwerken en verifiëren,
                  \item veranderingen pushen via SSH.
                \end{itemize}
          \item Zeer flexibel, ideaal voor maatwerk of complexe logica.
          \item Minder geschikt voor grootschalig configuratiebeheer dan Ansible:
                geen standaardinventaris, minder idempotentie, geen rollen/playbooks.
        \end{itemize}

\end{itemize}

\textbf{Conclusie}:  
Hoewel Puppet, Chef en Python-gebaseerde automatisatie elk waardevolle toepassingen hebben, is Ansible door zijn agentless-architectuur, leesbare YAML-configuraties en uitgebreide netwerkondersteuning het meest geschikt voor het doel van deze bachelorproef: schaalbare, consistente en foutreducerende netwerkautomatisatie binnen een kmo-context.


\subsection{Infrastructure as Code best practices}
\label{subsec:iac-best-practices}

Infrastructure as Code (IaC) is een manier waarbij infrastructuur beheerd wordt via machineleesbare configuratiebestanden in plaats van via manuele configuratie. 
Dit concept, dat oorspronkelijk werd ontwikkeld voor serverbeheer, is inmiddels uitgebreid naar netwerkinfrastructuur.

Bij het implementeren van IaC voor netwerken zijn er enkele fundamentele best practices:

\textbf{Idempotentie}: Configuraties moeten hetzelfde resultaat opleveren, ongeacht hoe vaak ze worden toegepast \autocite{Middleware2013}. 
Dit principe, centraal in tools zoals Ansible, garandeert voorspelbaarheid en voorkomt ongewenste wijzigingen.
Een idempotente operatie kan veilig meerdere keren worden uitgevoerd zonder neveneffecten.

\textbf{Declaratieve configuratie}: In plaats van te specificeren hoe een configuratie moet worden toegepast (imperatief), beschrijft men de gewenste eindtoestand (declaratief) \autocite{Endres2017}. 
Het systeem zorgt ervoor dat de infrastructuur in deze toestand wordt gebracht.
Dit abstractieniveau maakt configuraties leesbaarder en onderhoudsvriendelijker.

\textbf{Modulaire architectuur}: Configuraties worden opgesplitst in herbruikbare modules of rollen. 
Dit bevordert consistentie en versnelt het uitrollen van nieuwe toestellen.
In Ansible-context worden deze modules \textbf{roles} genoemd.

\textbf{Immutable infrastructure}: In plaats van bestaande configuraties aan te passen, worden nieuwe configuraties volledig opnieuw uitgerold. 
Dit principe, hoewel uitdagender voor netwerkapparatuur dan voor servers, verkleint de kans op configuration drift.

\section{Fundamentele concepten in netwerkautomatisering}
\label{sec:fundamentele-concepten}

\subsection{Idempotentie}
\label{subsec:idempotentie}

Idempotentie is een concept dat betekent dat een operatie meerdere keren kan worden uitgevoerd zonder dat het resultaat verandert, ongeacht of het één keer of meermaals uitgevoerd wordt \autocite{Geerling2020}.

Beschouw bijvoorbeeld de configuratie van een VLAN. Een idempotente operatie 
controleert eerst of VLAN 10 al bestaat. Indien dat het geval is, wordt geen actie 
ondernomen; indien niet, wordt het VLAN aangemaakt. Een tweede uitvoering van 
dezelfde taak verandert dus niets.

Niet-idempotente operaties kunnen echter wel tot foutieve of ongewenste 
configuraties leiden. Een veelvoorkomend voorbeeld is het automatisch toevoegen 
van access-listregels. Wanneer een automatisatietaak zonder idempotentiecontrole 
telkens dezelfde regel opnieuw pusht:

\begin{verbatim}
ip access-list extended BLOCK-SSH
  deny tcp any any eq 22
\end{verbatim}

kan dit resulteren in meerdere identieke entries:

\begin{verbatim}
deny tcp any any eq 22
deny tcp any any eq 22
deny tcp any any eq 22
\end{verbatim}

Dergelijke duplicaten vergroten de complexiteit van access-lists, bemoeilijken 
troubleshooting en kunnen zelfs de verwerkingsvolgorde van ACL's beïnvloeden. Dit 
illustreert hoe niet-idempotente automatisatie kan leiden tot configuratiedrift en 
fouten, en benadrukt het belang van idempotentie binnen netwerkautomatisering.

Dit principe is essentieel voor betrouwbare automatisering omdat het betekent dat playbooks veilig opnieuw kunnen worden uitgevoerd zonder ongewenste neveneffecten \autocite{Geerling2020}. 
Het maakt ook troubleshooting eenvoudiger: als een playbook halverwege faalt, kan het gewoon opnieuw worden gestart zonder dat eerdere stappen handmatig moeten worden teruggedraaid.

\subsection{Declaratieve versus imperatieve configuratie}
\label{subsec:declaratief-imperatief}

In imperatieve programmering specificeert men exact \emph{hoe} een taak moet worden uitgevoerd: een reeks stappen die in een bepaalde volgorde moeten worden uitgevoerd \autocite{Morris2020}.
Bijvoorbeeld:
\begin{verbatim}
1. Verbind met switch
2. Ga naar configuratiemodus
3. Maak VLAN 10 aan
4. Geef VLAN 10 de naam "Sales"
5. Wijs interface Gi0/1 toe aan VLAN 10
6. Sla configuratie op
\end{verbatim}

In declaratieve configuratie beschrijft men de gewenste eindtoestand, zonder te beschrijven hoe dat moet gebeuren \autocite{Morris2020}:
\begin{verbatim}
VLAN 10 moet bestaan
VLAN 10 moet naam "Sales" hebben
Interface Gi0/1 moet in VLAN 100 zitten
\end{verbatim}

Het voordeel van de declaratieve benadering is dat je je niet hoeft bezig te houden met alle implementatiestappen, maar enkel aangeeft wat je uiteindelijk wilt bereiken.
Dit maakt configuraties leesbaarder, onderhoudsvriendelijker en platform-onafhankelijker.
Ansible gebruikt voornamelijk een declaratieve benadering, hoewel het ook imperatieve elementen ondersteunt waar nodig.

\subsection{Keuze voor Ansible}
\label{subsec:keuze-ansible}

Voor deze bachelorproef is gekozen voor Ansible om de volgende redenen:

\textbf{Agentless architectuur}: Traditionele netwerkapparatuur zoals Cisco routers en switches bieden geen mogelijkheid om configuratie-agents te installeren. 
Dankzij de agentless aanpak van Ansible kan de configuratie van deze toestellen toch geautomatiseerd worden via SSH, zonder dat er wijzigingen aan de firmware of extra software op het apparaat nodig zijn.

\textbf{Lage instapdrempel}: YAML is een zeer leesbare configuratietaal die geen programmeerkennis vereist. 
Dit maakt Ansible toegankelijk voor netwerkadministratoren die geen of een zeer beperkte kennis van programmeren hebben \autocite{Geerling2020}.
In een kmo-context, waar teams vaak kleiner zijn en minder gespecialiseerd, is een lage instapdrempel van groot belang.

\textbf{Uitgebreide netwerkondersteuning}: Ansible heeft een grote collectie modules die specifiek zijn ontwikkeld voor populaire netwerkapparatuur, waaronder Cisco toestellen \autocite{AnsibleCiscoIOS}. 
Deze modules bieden een mogelijkheid een out-of-the-box oplossing voor veelvoorkomende netwerkconfiguraties.
Voor meer specifieke configuraties kunnen aangepaste modules worden ontwikkeld, kan gebruik worden gemaakt van Jinja2-templates om configuraties dynamisch te genereren op basis van variabelen of kunnen commandos worden meegeven zoals ze manueel in de CLI zouden worden meegegeven.
De cisco.ios collection biedt ondersteuning voor Cisco IOS-toestellen, wat relevant is voor deze proof-of-concept.

\textbf{Community en documentatie}: Als populaire configuratietool heeft Ansible een grote, actieve community die hulp kan bieden. 
Daarnaast heeft Ansible uitgebreide documentatie, zowel voor de basisopstelling van een Ansible omgeving als elke module die ter beschikking is. 
Deze elementen zijn een grote meerwaarde voor troubleshooting en kennisuitwisseling.

\textbf{Schaalbaarheid}: 
Ansible is ontworpen om zowel kleine als zeer grote omgevingen efficiënt te beheren. 
De agentless architectuur zorgt ervoor dat extra netwerktoestellen geen bijkomende 
software-installatie vereisen, wat de operationele overhead minimaal houdt. Bovendien 
ondersteunt Ansible \textit{parallel execution}, waardoor tientallen en zelfs honderden 
routers en switches gelijktijdig geconfigureerd kunnen worden. Dit maakt Ansible geschikt 
voor kmo's die groeien en later willen opschalen naar complexere netwerkomgevingen.

Daarnaast maakt het gebruik van een \textit{inventory-abstractie}, waarbij toestellen in 
groepen kunnen worden beheerd en geparametriseerd, het mogelijk om configuraties consistent 
en herhaalbaar toe te passen op grote aantallen apparaten. Volgens \textcite{Morris2020} 
is schaalbare, geautomatiseerde configuratie een kernprincipe van Infrastructure as Code, 
omdat het toelaat om zonder manuele tussenkomst grote aantallen systemen te beheren. 

\textbf{Tijdbesparing}:
De gelijktijdige configuratie van tientallen en tot honderden toestellen biedt naast schaalbaarheid ook een enorme tijdbesparing.
Bij een manuele configuratie zou één enkele netwerkadministrator elk netwerktoestel één voor één en lijn per lijn moeten configureren, wat bij een groot netwerk snel kan uitlopen tot uren en soms dagen.
Doordat Ansible de mogelijkheid tot gelijktijdige configuratie biedt, kan men de tijd die nodig is voor het configureren van een groot aantal toestellen drastisch verminderen. 

\textbf{Conclusie}: Deze eigenschappen maken Ansible geschikt voor het doel van deze bachelorproef: snellere, reproduceerbare en consistente, schaalbare en foutreducerende netwerkconfiguratie binnen een kmo-context.

\section{Ansible in netwerkautomatisering}
\label{sec:ansible}

Ansible werd oorspronkelijk ontwikkeld door Michael DeHaan in 2012 voor serverbeheer en werd in 2015 overgenomen door Red Hat, inmiddels is het een volwaardige NetDevOps-tool geworden met uitgebreide ondersteuning voor netwerkapparatuur.

\subsection{Ansible architectuur}
\label{subsec:ansible-architectuur}

De Ansible-architectuur bestaat uit drie hoofdcomponenten:

\textbf{Control node}: De machine waarop Ansible is geïnstalleerd en van waaruit playbooks worden uitgevoerd. 
Dit kan een laptop, server of CI/CD-systeem (Continuous Integration en Continuous Delivery) zijn. 
De control node heeft Python nodig maar legt verder minimale eisen op.

\textbf{Managed nodes}: De systemen die door Ansible worden beheerd.
Voor netwerkapparaten is alleen SSH nodig; Ansible communiceert via de CLI.

\textbf{Inventory}: Een bestand (of dynamische bron) dat definieert welke nodes moeten worden beheerd en hoe ze worden gegroepeerd. 
Inventories kunnen statisch (YAML- of INI-bestanden) of dynamisch (scripts die nodes ophalen uit externe bronnen) zijn.

\subsection{Kernconcepten}
\label{subsec:ansible-kernconcepten}

De werking van Ansible steunt op zes kernelementen, 3 daarvan zijn van belang voor dit onderzoek en worden hieronder uitgelegd \autocite{AnsibleArchitecture}:

\subsubsection{Inventories}
\label{subsubsec:inventories}

Een inventory is een lijst met managed nodes, optioneel georganiseerd in groepen. 
Het meegegeven IP-adres stelt Ansible er toe in staat te weten hoe de managed node aangesproken moet worden.
Een eenvoudig voorbeeld:

\begin{verbatim}
[switches]
sw1 ansible_host=192.168.1.10
sw2 ansible_host=192.168.1.11
sw3 ansible_host=192.168.1.12

[routers]
r1 ansible_host=192.168.1.1
r2 ansible_host=192.168.1.2

[cisco:children]
switches
routers

\end{verbatim}

In het bovenstaandde voorbeeld worden drie switches gedefiniëerd, in een groep 'switches' en twee routers, in een groep 'routers'. 
Er wordt ook een geneste groep 'cisco' gedefiniëerd waaronder de groepen switches en routers vallen. 
Doordat er groepen zijn gemaakt kan de netwerkadministrator kiezen welke toestellen hij aanspreekt:

\begin{itemize}
  \item \textbf{specifiek toestel}: operaties zullen enkel op het gekozen toestel uitgevoerd worden.
  \item \textbf{groep}: operaties zullen op alle toestellen die in deze groep zitten uitgevoerd worden.
  \item \textbf{geneste groep}: operaties zullen op alle toestellen die in de groepen in deze geneste groep zitten uitgevoerd worden.
\end{itemize}

Inventories ondersteunen dus operaties en variabelen op host- en groepsniveau, waardoor configuraties kunnen worden aangepast per toestel of groep.
Een voordeel hiervan is dat basisopstellingen vaak grotendeels hetzelfde zijn voor netwerktoestellen en dus met één enkel playbook op alle toestellen toegepast kan worden.

\subsubsection{Playbooks}
\label{subsubsec:playbooks}

